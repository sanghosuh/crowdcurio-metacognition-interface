var ReconnectingWebSocket = require('reconnectingwebsocket');

Array.prototype.diff = function (a) {
    return this.filter(function (i) {
        return a.indexOf(i) === -1;
    });
};

function print(message){
    var currentDate = '[' + new Date().toUTCString() + '] ';
    console.log(currentDate+message)
}

function TaskSession(){
    this.model = 'tasksession';
    this.client = null;
    this.present = null;
    this.connected = false;
    this.connected_users = [];

    // relations
    this.user = null;
    this.task = null;
    this.experiment = null;
    this.condition = null;
    this.task_session = null;
    this.task_session_policy = null;
    this.socket = null;

    // ui action bindings
    this.handleInterfaceActionSave = null;
    this.handleInterfaceActionDelete = null;
}

/**
 * Initializes the TaskSession instance by fetching the associated policy and 
 * retrieving a session for the user.
 * @param {Object} params 
 */
TaskSession.prototype.init = function(params) {
    var that = this;
    return new Promise(function(resolve, reject) {
        print('Initializing session.');

        // authenticate & instantiate the client's connection
        that.client = params['client']

        // set (1) task and (2) experiment vars
        that.user = {id: params['user'], type: 'User'};
        that.task = {id: params['task'], type: 'Task'};
        if(params['experiment']){
            that.experiment = {id: params['experiment'], type: 'Experiment'}
        } else {
            that.experiment = null;
        }
        if(params['condition']){
            that.condition = {id: params['condition'], type: 'Condition'}
        } else {
            that.condition = null;
        }

        // set a default handler for receiving ui events
        that.handleInterfaceActionSave = function(event){
            print("ERROR: Can't handle transmitted Interface Save event. (E: "+event+" )");
        }
        that.handleInterfaceActionDelete = function(event){
            print("ERROR: Can't handle transmitted Inteface Delete event. (E: "+event+" )");
        }

        // fetch the task policy
        that.fetchPolicy().then(function(policy){
            if(policy !== null){
                that.task_session_policy = policy;

                // find the task session id for the user
                that.find().then(function(id){
                    print("Session Retrieved: "+id);
                    that.task_session = id;
                    that.connect(that.task_session);
                    
                    // resolve after we have the connection
                    resolve();
                });
            } else {
                print("ERROR: Can't find an associated policy.")
            }
        });
    }.bind());
}

/**
 * Sets callbacks that are executed when new events are sent and received.
 * 
 *  Structure of obj should be:
 *      {
 *          'send': function(){ ... },
 *          'receive': function(){ ... }
 *      }
 * 
 * @param {Object} obj 
 */
TaskSession.prototype.setListeners = function(obj){
    if('save' in obj && typeof obj['save'] === "function"){
        this.handleInterfaceActionSave = obj['save'];
    }
    if('delete' in obj && typeof obj['delete'] === "function"){
        this.handleInterfaceActionDelete = obj['delete'];
    }
};

/**
 * Creates a TaskSession objects with a given channel name.
 * @param {String} channel_name 
 */
TaskSession.prototype.create = function(channel_name){
    return new Promise(function(resolve, reject) {
        // This function should find the session for the user.
        print("Creating Session ...");

        // set params
        params = {
            //slug: 'task-session-'+this.task.id +'-'+this.experiment.id+'-'+this.condition.id,//+Math.random().toString(36).substr(2, 9),
            task: this.task,
            experiment: this.experiment,
            condition: this.condition,
            channel_name: channel_name
        }

        let action = [this.model, "create"];
        this.client.action(schema, action, params).then(function(resp) {
            print("Session Created:");
            resolve(resp.id);
        });
    }.bind(this));
}

/**
 * Finds the Task Session ID for the User.
 *  Step (1): Check if User belongs to a session for this task / experiment / condition combination.
 *  Step (2): If not, find a task session with available space.
 *  Step (3): If all sessions are full, create a new task session.
 */
TaskSession.prototype.find = function(){
    var that = this;
    return new Promise(function(resolve, reject) {
        print("Finding an available task session ...");
        $.ajaxSetup({
            beforeSend: function(xhr, settings) {
                if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                    xhr.setRequestHeader("X-CSRFToken", csrftoken);
                }
            }
        });

        $.ajax({
            type: 'POST',
            url: "/collaboration/route/",
            data: {
                'csrftoken': csrftoken,
                'user': that.user.id,
                'experiment': that.experiment.id,
                'condition': that.condition.id,
                'task': that.task.id
            },
            success: function(payload){
                /* on success, just refresh the page */
                print("Payload:");
                console.log(payload);
                that.channel_name = payload['channel_name'];
                resolve(payload['session_id']);
            }
        });
    }.bind(this));
}

/**
 * Fetches the Task Policy used for auto-generating task sessions.
 */
TaskSession.prototype.fetchPolicy = function(){
    var that = this;
    return new Promise(function(resolve, reject) {
        print("Fetching policy ...");

        // set params
        params = {
            task: this.task.id,
            experiment: this.experiment.id,
            condition: this.condition.id
        }

        let action = ['tasksessionpolicy', "list"];
        this.client.action(schema, action, params).then(function(resp) {
            if(resp.count < 1){
                // if we get here, no policy exists for generating task sessions.
                resolve(null);
            } else {
                print("Policy retrieved: "+resp.results[0].id);
                resolve(resp.results[0].id);
            }
        });
    }.bind(this));
}

/**
 * Connects and maintains a valid websocket connection for a particula task session
 */
TaskSession.prototype.connect = function(roomId){
    $("#task-container").append('<div id="chats"></div>');

    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    var ws_path = ws_scheme + '://' + window.location.host + "/collaboration/stream/";
    print("Connecting: " + ws_path);
    this.socket = new ReconnectingWebSocket(ws_path);
    var that = this;

    function updateUserList(){
        // recursively check if the chat interface has rendered. when it has, update the count.
        if($("#chat-user-count").length === 0){
            setTimeout(function(){
                updateUserList();
            }, 100);
            return;
        } else {
            var data = that.userList;
            // update the user count
            var ele = $("#chat-user-count");
            ele.empty().html(data['payload']['members'].length + ' <i class="fa fa-user" aria-hidden="true"></i>');

            // build the new tooltip html
            var tooltip_html = '';
            for(var i=0; i < data['payload']['members'].length; i++){
                tooltip_html += data['payload']['members'][i];
                if(i != data['payload']['members'.length-1]){
                    tooltip_html += '<br/>';
                }
            }

            // find the difference between the connected users and the new set of task session members
            var diff = that.connected_users.diff(data['payload']['members']);
            var diff = diff[0];

            // if there's a difference, update the ui.
            if(typeof diff !== 'undefined' && diff){
                // add the message for the user who left and scroll
                var msgdiv = $('#chat-messages');
                msgdiv.append("<div class='contextual-message text-muted'>" + diff + " left the room!" + "</div>");
                msgdiv.scrollTop(msgdiv.prop("scrollHeight"));
            }   

            // update the tooltip
            ele.attr('data-tooltip', tooltip_html);
            ele.tooltip({delay: 25, tooltip: tooltip_html, html: true});

            // update the list of connected users
            that.connected_users = data['payload']['members'];
        }
    }

    // Helpful debugging
    this.socket.onopen = function () {
        if(that.connected){
            return;
        }

        that.connected = true;

        print("Connected: "+roomId);
        that.socket.send(JSON.stringify({
            "command": "join",  // determines which handler will be used (see chat/routing.py)
            "task_session": roomId,
            "channel_name": that.channel_name,
            "task": that.task.id,
            "experiment": that.experiment.id,
            "condition": that.condition.id,
        }));

        /* fetch the last 10 messages */
        that.fetch("message", {task_session: roomId}, function(messages){
            function convertTimestamp(ts){
                var v = ts.split('T')
                var t = v[0].split('-');
                var year = t[0];
                var month = t[2];
                var day = t[1];
                var time = v[1].split('.')[0].split(',')[0];
                return day+"/"+month+"/"+year+" @ "+time;
            }

            var message_set = '';
            for(var i=messages.results.length-1; i >= 0; i--){
                var message = messages.results[i]
                var navbar_username = $("#user-logged-in a").text();
                var direction = 'in';
                if(navbar_username === message.handle){
                    direction = 'out';
                }
                var message_time = message.created;

                // Message
                ok_msg = '<div class="message '+direction+' no-avatar">\
                        <!-- BEGIN MESSAGE SENDER INFO -->\
                        <div class="sender">\
                            <a href="javascript:void(0);" title="Rufat Askerov">\
                                <img src="assets/img/avatar.png" class="avatar" alt="Rufat Askerov">\
                            </a>\
                        </div>\
                        <!-- END MESSAGE SENDER INFO -->\
                        <div class="body">\
                        <!-- BEGIN MESSAGE CONTENT-->\
                        <div class="content"><span>'+message.content+'</span></div>\
                        <!-- BEGIN MESSAGE CONTENT  -->\
                        <!-- BEGIN MESSAGE SEND TIME -->\
                        <div class="seen"><span>'+convertTimestamp(message_time)+'</span> </div>\
                        <!-- BEGIN MESSAGE SEND TIME -->\
                        </div>\
                        <div class="clear"></div>\
                    </div>';
                message_set+=ok_msg;
            };
            var msgdiv = $(".messages");
            msgdiv.append(message_set);

            // scroll to the bottom of the messages div
            var msgdiv = $('#chat-messages');
            msgdiv.scrollTop(msgdiv.prop("scrollHeight"));
        });
    };

    that.socket.onclose = function () {
        print("Disconnected from chat socket");
        that.socket.send(JSON.stringify({
            "command": "leave",  // determines which handler will be used (see chat/routing.py)
            "task_session": roomId
        }));
    };

    that.socket.onmessage = function (message) {
        // Decode the JSON
        print(":RCVD: " + message.data);
        var data = JSON.parse(message.data);
        // Handle errors
        if (data.error) {
            alert(data.error);
            return;
        }
        // Handle joining
        if (data.payload.join) {
            if($("#default-chat-box-header").length === 0){
                /* create chat box */
                var roomdiv = $(
                    '<!-- BEGIN CHAT BOX HEADER -->\
                    <div id="default-chat-box-header" class="box-header blue-grey darken-4">\
                        <!-- BEGIN USER INFO -->\
                        <div class="info">\
                            <span class="box-username">\
                                <a href="#">Chat\
                            </span>\
                        </div>\
                        <!-- END USER INFO -->\
                        <a href="#" style="float: right;margin-right: 15px;color: white;"><i class="fa fa-cog" aria-hidden="true"></i><!-- END USER INFO --></a>\
                        <a id="chat-user-count" href="#" style="float: right;margin-right: 15px;color: white;" class="tooltipped" data-position="top" data-delay="25" data-tooltip="You">\
                            <div class="preloader-wrapper small active" style="height:18px;width:18px;">\
                                <div class="spinner-layer spinner-green-only">\
                                <div class="circle-clipper left">\
                                    <div class="circle"></div>\
                                </div><div class="gap-patch">\
                                    <div class="circle"></div>\
                                </div><div class="circle-clipper right">\
                                    <div class="circle"></div>\
                                </div>\
                                </div>\
                            </div>\
                        </a>\
                    </div>\
                    <!-- END CHAT BOX HEADER -->\
                    <!-- BEGIN CHAT BOX BODY -->\
                    <div class="box-body">\
                        <div class="status online"></div>\
                        <!-- BEGIN MESSAGES -->\
                        <div class="message-scrooler">\
                            <div id="chat-messages" class="messages">\
                            </div>\
                        </div>\
                    </div>\
                    <!-- END MESSAGES -->\
                </div>\
                <!-- END CHAT BOX BODY -->\
                <!-- BEGIN CHAT BOX FOOTER -->\
                <div class="box-footer">\
                    <!-- BEGIN  WRITE MESSAGE -->\
                    <div class="item send-message">\
                        <input id="chat-input-box" class="textarea" placeholder="Write message">\
                        </input>\
                    </div>\
                    <!-- END WRITE MESSAGE -->\
                    <!-- BEGIN ADD FILE -->\
                    <div id="chat-send-button" class="item file">\
                    <i class="fa fa-paper-plane" aria-hidden="true"></i>\
                    </div>\
                    <!-- END ADD FILE -->\
                </div>\
                <!-- END CHAT BOX FOOTER -->\
                <div class="box-footer-end blue-grey darken-4"></div>');
                $("#chats").append(roomdiv);
                $("#chat-send-button").on("click", function () {
                    that.socket.send(JSON.stringify({
                        "command": "send",
                        "task_session": data.payload.join,
                        "message": $("#chat-input-box").val().trim()
                    }));
                    $("#chat-input-box").val("");
                });

                // add the tooltip functionality
                $('.tooltipped').tooltip({delay: 25, tooltip: 'Loading', html: true});

                $("#chat-input-box").keypress(function(e) {
                    if(e.which == 13) {
                        that.socket.send(JSON.stringify({
                            "command": "send",
                            "task_session": data.payload.join,
                            "message": $("#chat-input-box").val().trim()
                        }));
                        $("#chat-input-box").val("");
                    }
                });
            }
            // Handle leaving
        } else if (data.payload.leave) {
            print("Leaving room " + data.payload.leave);
            $("#room-" + data.payload.leave).remove();
        } else if (data.payload.message || data.msg_type !== 0) {
            var msgdiv = $(".messages");
            var ok_msg = "";
            // msg types are defined in chat/settings.py
            // Only for demo purposes is hardcoded, in production scenarios, consider call a service.
            switch (data.msg_type) {
                case 0:
                    var navbar_username = $("#user-logged-in a").text();
                    var direction = 'in';
                    if(navbar_username === data.payload.username){
                        direction = 'out';
                    }

                    // calculate time
                    var currentdate = new Date(); 
                    var datetime = (currentdate.getMonth()+1) + "/"
                                    + currentdate.getDate()  + "/" 
                                    + currentdate.getFullYear() + " @ "  
                                    + currentdate.getHours() + ":"  
                                    + currentdate.getMinutes() + ":" 
                                    + currentdate.getSeconds();

                    // Message
                    ok_msg = '<div class="message '+direction+' no-avatar">\
                            <!-- BEGIN MESSAGE SENDER INFO -->\
                            <div class="sender">\
                                <a href="javascript:void(0);" title="Rufat Askerov">\
                                    <img class="avatar" alt="Rufat Askerov">\
                                </a>\
                            </div>\
                            <!-- END MESSAGE SENDER INFO -->\
                            <div class="body">\
                            <!-- BEGIN MESSAGE CONTENT-->\
                            <div class="content"><span>'+data.payload.message+'</span></div>\
                            <!-- BEGIN MESSAGE CONTENT  -->\
                            <!-- BEGIN MESSAGE SEND TIME -->\
                            <div class="seen"><span>'+datetime+'</span> </div>\
                            <!-- BEGIN MESSAGE SEND TIME -->\
                            </div>\
                            <div class="clear"></div>\
                        </div>';
                    break;
                case 1:
                    // Warning/Advice messages
                    ok_msg = "<div class='contextual-message text-warning'>" + data.payload.message + "</div>";
                    break;
                case 2:
                    // Alert/Danger messages
                    ok_msg = "<div class='contextual-message text-danger'>" + data.payload.message + "</div>";
                    break;
                case 3:
                    // "Muted" messages
                    ok_msg = "<div class='contextual-message text-muted'>" + data.payload.message + "</div>";
                    break;
                case 4:
                    // User joined room
                    ok_msg = "<div class='contextual-message text-muted'>" + data.payload.username + " joined the room!" + "</div>";
                    break;
                case 5:
                    // User left room
                    ok_msg = "<div class='contextual-message text-muted'>" + data.payload.username + " left the room!" + "</div>";
                    break;
                case 6: // Server is updating us with active users in session
                    that.userList = data;
                    updateUserList();
                    return;
                case 9:
                    that.handleInterfaceActionSave(data);
                    break;
                case 10:
                    that.handleInterfaceActionDelete(data);
                    break;
                default:
                    print("Unsupported message type!");
                    return;
            }
            msgdiv.append(ok_msg);
            msgdiv.scrollTop(msgdiv.prop("scrollHeight"));
        } else {
            print("Cannot handle message!");
        }
    };

}

/**
 * Sends an interface event to the websocket.
 * @param {*} msg 
 */
TaskSession.prototype.send = function(event){
    var that = this;
    this.socket.send(JSON.stringify({
        "command": "interface",
        "task_session": that.task_session,
        "event": event
    }));
}

/**
 * A general-purpose function for listing data from the server.
 * @param {*} model 
 * @param {*} callback 
 */
TaskSession.prototype.fetch = function(model, params, callback){
    let action = ["message", "list"];
    this.client.action(schema, action, params).then(function(resp) {
        callback(resp);
    });
}

/**
 * A general-purpose function for loading state from the server.
 * @param {*} model 
 * @param {*} callback 
 */
TaskSession.prototype.loadState = function(callback){
    var that = this;
    var params = {
        data: that.client.data.id,
        task: that.task.id,
        experiment: that.experiment.id,
        condition: that.condition.id
    };

    let action = ["annotation", "list"];
    this.client.action(schema, action, params).then(function(resp) {
        callback(resp.results);
    });
}

module.exports = TaskSession;